{
  "version": 3,
  "sources": ["../../react-use-measure/src/index.ts", "../../react-modal-sheet/src/context.tsx", "../../react-modal-sheet/src/styles.ts", "../../react-modal-sheet/src/constants.ts", "../../react-modal-sheet/src/utils.ts", "../../react-modal-sheet/src/SheetBackdrop.tsx", "../../react-modal-sheet/src/SheetContainer.tsx", "../../react-modal-sheet/src/hooks/use-drag-constraints.ts", "../../react-modal-sheet/src/hooks/use-scroll-position.ts", "../../react-modal-sheet/src/SheetContent.tsx", "../../react-modal-sheet/src/SheetDragIndicator.tsx", "../../react-modal-sheet/src/SheetHeader.tsx", "../../react-modal-sheet/src/hooks/use-isomorphic-layout-effect.ts", "../../react-modal-sheet/src/hooks/use-dimensions.ts", "../../react-modal-sheet/src/hooks/use-safe-area-insets.ts", "../../react-modal-sheet/src/hooks/use-modal-effect.ts", "../../react-modal-sheet/src/hooks/use-prevent-scroll.ts", "../../react-modal-sheet/src/hooks/use-stable-callback.ts", "../../react-modal-sheet/src/hooks/use-sheet-state.ts", "../../react-modal-sheet/src/hooks/use-virtual-keyboard.ts", "../../react-modal-sheet/src/snap.ts", "../../react-modal-sheet/src/sheet.tsx", "../../react-modal-sheet/src/index.tsx"],
  "sourcesContent": ["import { useEffect, useState, useRef, useMemo } from 'react'\r\n\r\nfunction createDebounce<T extends (...args: any[]) => void>(callback: T, ms: number) {\r\n  let timeoutId: number\r\n\r\n  return (...args: Parameters<T>): void => {\r\n    window.clearTimeout(timeoutId)\r\n    timeoutId = window.setTimeout(() => callback(...args), ms)\r\n  }\r\n}\r\n\r\ndeclare type ResizeObserverCallback = (entries: any[], observer: ResizeObserver) => void\r\ndeclare class ResizeObserver {\r\n  constructor(callback: ResizeObserverCallback)\r\n  observe(target: Element, options?: any): void\r\n  unobserve(target: Element): void\r\n  disconnect(): void\r\n  static toString(): string\r\n}\r\n\r\nexport interface RectReadOnly {\r\n  readonly x: number\r\n  readonly y: number\r\n  readonly width: number\r\n  readonly height: number\r\n  readonly top: number\r\n  readonly right: number\r\n  readonly bottom: number\r\n  readonly left: number\r\n  [key: string]: number\r\n}\r\n\r\ntype HTMLOrSVGElement = HTMLElement | SVGElement\r\n\r\ntype Result = [(element: HTMLOrSVGElement | null) => void, RectReadOnly, () => void]\r\n\r\ntype State = {\r\n  element: HTMLOrSVGElement | null\r\n  scrollContainers: HTMLOrSVGElement[] | null\r\n  resizeObserver: ResizeObserver | null\r\n  lastBounds: RectReadOnly\r\n  orientationHandler: null | (() => void)\r\n}\r\n\r\nexport type Options = {\r\n  debounce?: number | { scroll: number; resize: number }\r\n  scroll?: boolean\r\n  polyfill?: { new (cb: ResizeObserverCallback): ResizeObserver }\r\n  offsetSize?: boolean\r\n}\r\n\r\nfunction useMeasure(\r\n  { debounce, scroll, polyfill, offsetSize }: Options = { debounce: 0, scroll: false, offsetSize: false },\r\n): Result {\r\n  const ResizeObserver =\r\n    polyfill || (typeof window === 'undefined' ? class ResizeObserver {} : (window as any).ResizeObserver)\r\n\r\n  if (!ResizeObserver) {\r\n    throw new Error(\r\n      'This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills',\r\n    )\r\n  }\r\n\r\n  const [bounds, set] = useState<RectReadOnly>({\r\n    left: 0,\r\n    top: 0,\r\n    width: 0,\r\n    height: 0,\r\n    bottom: 0,\r\n    right: 0,\r\n    x: 0,\r\n    y: 0,\r\n  })\r\n\r\n  // keep all state in a ref\r\n  const state = useRef<State>({\r\n    element: null,\r\n    scrollContainers: null,\r\n    resizeObserver: null,\r\n    lastBounds: bounds,\r\n    orientationHandler: null,\r\n  })\r\n\r\n  // set actual debounce values early, so effects know if they should react accordingly\r\n  const scrollDebounce = debounce ? (typeof debounce === 'number' ? debounce : debounce.scroll) : null\r\n  const resizeDebounce = debounce ? (typeof debounce === 'number' ? debounce : debounce.resize) : null\r\n\r\n  // make sure to update state only as long as the component is truly mounted\r\n  const mounted = useRef(false)\r\n  useEffect(() => {\r\n    mounted.current = true\r\n    return () => void (mounted.current = false)\r\n  })\r\n\r\n  // memoize handlers, so event-listeners know when they should update\r\n  const [forceRefresh, resizeChange, scrollChange] = useMemo(() => {\r\n    const callback = () => {\r\n      if (!state.current.element) return\r\n      const { left, top, width, height, bottom, right, x, y } =\r\n        state.current.element.getBoundingClientRect() as unknown as RectReadOnly\r\n\r\n      const size = {\r\n        left,\r\n        top,\r\n        width,\r\n        height,\r\n        bottom,\r\n        right,\r\n        x,\r\n        y,\r\n      }\r\n\r\n      if (state.current.element instanceof HTMLElement && offsetSize) {\r\n        size.height = state.current.element.offsetHeight\r\n        size.width = state.current.element.offsetWidth\r\n      }\r\n\r\n      Object.freeze(size)\r\n      if (mounted.current && !areBoundsEqual(state.current.lastBounds, size)) set((state.current.lastBounds = size))\r\n    }\r\n    return [\r\n      callback,\r\n      resizeDebounce ? createDebounce(callback, resizeDebounce) : callback,\r\n      scrollDebounce ? createDebounce(callback, scrollDebounce) : callback,\r\n    ]\r\n  }, [set, offsetSize, scrollDebounce, resizeDebounce])\r\n\r\n  // cleanup current scroll-listeners / observers\r\n  function removeListeners() {\r\n    if (state.current.scrollContainers) {\r\n      state.current.scrollContainers.forEach((element) => element.removeEventListener('scroll', scrollChange, true))\r\n      state.current.scrollContainers = null\r\n    }\r\n\r\n    if (state.current.resizeObserver) {\r\n      state.current.resizeObserver.disconnect()\r\n      state.current.resizeObserver = null\r\n    }\r\n\r\n    if (state.current.orientationHandler) {\r\n      if ('orientation' in screen && 'removeEventListener' in screen.orientation) {\r\n        screen.orientation.removeEventListener('change', state.current.orientationHandler)\r\n      } else if ('onorientationchange' in window) {\r\n        window.removeEventListener('orientationchange', state.current.orientationHandler)\r\n      }\r\n    }\r\n  }\r\n\r\n  // add scroll-listeners / observers\r\n  function addListeners() {\r\n    if (!state.current.element) return\r\n    state.current.resizeObserver = new ResizeObserver(scrollChange)\r\n    state.current.resizeObserver!.observe(state.current.element)\r\n    if (scroll && state.current.scrollContainers) {\r\n      state.current.scrollContainers.forEach((scrollContainer) =>\r\n        scrollContainer.addEventListener('scroll', scrollChange, { capture: true, passive: true }),\r\n      )\r\n    }\r\n\r\n    // Handle orientation changes\r\n    state.current.orientationHandler = () => {\r\n      scrollChange()\r\n    }\r\n\r\n    // Use screen.orientation if available\r\n    if ('orientation' in screen && 'addEventListener' in screen.orientation) {\r\n      screen.orientation.addEventListener('change', state.current.orientationHandler)\r\n    } else if ('onorientationchange' in window) {\r\n      // Fallback to orientationchange event\r\n      window.addEventListener('orientationchange', state.current.orientationHandler)\r\n    }\r\n  }\r\n\r\n  // the ref we expose to the user\r\n  const ref = (node: HTMLOrSVGElement | null) => {\r\n    if (!node || node === state.current.element) return\r\n    removeListeners()\r\n    state.current.element = node\r\n    state.current.scrollContainers = findScrollContainers(node)\r\n    addListeners()\r\n  }\r\n\r\n  // add general event listeners\r\n  useOnWindowScroll(scrollChange, Boolean(scroll))\r\n  useOnWindowResize(resizeChange)\r\n\r\n  // respond to changes that are relevant for the listeners\r\n  useEffect(() => {\r\n    removeListeners()\r\n    addListeners()\r\n  }, [scroll, scrollChange, resizeChange])\r\n\r\n  // remove all listeners when the components unmounts\r\n  useEffect(() => removeListeners, [])\r\n  return [ref, bounds, forceRefresh]\r\n}\r\n\r\n// Adds native resize listener to window\r\nfunction useOnWindowResize(onWindowResize: (event: Event) => void) {\r\n  useEffect(() => {\r\n    const cb = onWindowResize\r\n    window.addEventListener('resize', cb)\r\n    return () => void window.removeEventListener('resize', cb)\r\n  }, [onWindowResize])\r\n}\r\nfunction useOnWindowScroll(onScroll: () => void, enabled: boolean) {\r\n  useEffect(() => {\r\n    if (enabled) {\r\n      const cb = onScroll\r\n      window.addEventListener('scroll', cb, { capture: true, passive: true })\r\n      return () => void window.removeEventListener('scroll', cb, true)\r\n    }\r\n  }, [onScroll, enabled])\r\n}\r\n\r\n// Returns a list of scroll offsets\r\nfunction findScrollContainers(element: HTMLOrSVGElement | null): HTMLOrSVGElement[] {\r\n  const result: HTMLOrSVGElement[] = []\r\n  if (!element || element === document.body) return result\r\n  const { overflow, overflowX, overflowY } = window.getComputedStyle(element)\r\n  if ([overflow, overflowX, overflowY].some((prop) => prop === 'auto' || prop === 'scroll')) result.push(element)\r\n  return [...result, ...findScrollContainers(element.parentElement)]\r\n}\r\n\r\n// Checks if element boundaries are equal\r\nconst keys: (keyof RectReadOnly)[] = ['x', 'y', 'top', 'bottom', 'left', 'right', 'width', 'height']\r\nconst areBoundsEqual = (a: RectReadOnly, b: RectReadOnly): boolean => keys.every((key) => a[key] === b[key])\r\n\r\nexport default useMeasure\r\n", "import { createContext, useContext } from 'react';\nimport { type SheetContextType } from './types';\n\nexport const SheetContext = createContext<SheetContextType | undefined>(\n  undefined\n);\n\nexport function useSheetContext() {\n  const context = useContext(SheetContext);\n  if (!context) throw new Error('Sheet context error');\n  return context;\n}\n", "import type { CSSProperties } from 'react';\n\nexport const styles = {\n  root: {\n    base: {\n      position: 'fixed',\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0,\n      overflow: 'hidden',\n      pointerEvents: 'none',\n    },\n    decorative: {},\n  },\n  backdrop: {\n    base: {\n      zIndex: 1,\n      position: 'fixed',\n      top: 0,\n      left: 0,\n      width: '100%',\n      height: '100%',\n      touchAction: 'none',\n      userSelect: 'none',\n    },\n    decorative: {\n      backgroundColor: 'rgba(0, 0, 0, 0.2)',\n      border: 'none',\n      WebkitTapHighlightColor: 'transparent',\n    },\n  },\n  container: {\n    base: {\n      zIndex: 2,\n      position: 'absolute',\n      left: 0,\n      bottom: 0,\n      width: '100%',\n      pointerEvents: 'auto',\n      display: 'flex',\n      flexDirection: 'column',\n    },\n    decorative: {\n      backgroundColor: '#fff',\n      borderTopRightRadius: '8px',\n      borderTopLeftRadius: '8px',\n      boxShadow: '0px -2px 16px rgba(0, 0, 0, 0.3)',\n    },\n  },\n  headerWrapper: {\n    base: {\n      width: '100%',\n    },\n    decorative: {},\n  },\n  header: {\n    base: {\n      width: '100%',\n      position: 'relative',\n    },\n    decorative: {\n      height: '40px',\n      display: 'flex',\n      alignItems: 'center',\n      justifyContent: 'center',\n    },\n  },\n  indicatorWrapper: {\n    base: {\n      display: 'flex',\n    },\n    decorative: {},\n  },\n  indicator: {\n    base: {\n      display: 'inline-block',\n    },\n    decorative: {\n      width: '18px',\n      height: '4px',\n      borderRadius: '99px',\n      backgroundColor: '#ddd',\n    },\n  },\n  content: {\n    base: {\n      minHeight: '0px',\n      position: 'relative',\n      flexGrow: 1,\n      display: 'flex',\n      flexDirection: 'column',\n    },\n    decorative: {},\n  },\n  scroller: {\n    base: {\n      height: '100%',\n      overflowY: 'auto',\n      overscrollBehaviorY: 'none',\n    },\n    decorative: {},\n  },\n} satisfies Record<\n  string,\n  {\n    base: CSSProperties;\n    decorative: CSSProperties;\n  }\n>;\n", "import type { SheetTweenConfig } from './types';\n\nexport const DEFAULT_HEIGHT = 'calc(100% - env(safe-area-inset-top) - 34px)';\n\nexport const IS_SSR = typeof window === 'undefined';\n\nexport const DEFAULT_TWEEN_CONFIG: SheetTweenConfig = {\n  ease: 'easeOut',\n  duration: 0.2,\n};\n\nexport const REDUCED_MOTION_TWEEN_CONFIG: SheetTweenConfig = {\n  ease: 'linear',\n  duration: 0.01,\n};\n\nexport const DEFAULT_DRAG_CLOSE_THRESHOLD = 0.6;\n\nexport const DEFAULT_DRAG_VELOCITY_THRESHOLD = 500;\n", "import { type CSSProperties, type ForwardedRef, type RefCallback } from 'react';\nimport { IS_SSR } from './constants';\n\nexport function applyStyles(\n  styles: { base: CSSProperties; decorative: CSSProperties },\n  unstyled: boolean\n) {\n  return unstyled ? styles.base : { ...styles.base, ...styles.decorative };\n}\n\nexport function isAscendingOrder(arr: number[]) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i + 1] < arr[i]) return false;\n  }\n  return true;\n}\n\nexport function mergeRefs<T = any>(refs: ForwardedRef<T>[]): RefCallback<T> {\n  return (value: any) => {\n    refs.forEach((ref: any) => {\n      if (typeof ref === 'function') {\n        ref(value);\n      } else if (ref) {\n        ref.current = value;\n      }\n    });\n  };\n}\n\nexport function isTouchDevice() {\n  if (IS_SSR) return false;\n  return 'ontouchstart' in window || navigator.maxTouchPoints > 0;\n}\n\nfunction testPlatform(re: RegExp) {\n  return typeof window !== 'undefined' && window.navigator != null\n    ? re.test(\n        // @ts-expect-error\n        window.navigator.userAgentData?.platform || window.navigator.platform\n      )\n    : false;\n}\n\nfunction cached(fn: () => boolean) {\n  let res: boolean | null = null;\n  return () => {\n    if (res == null) {\n      res = fn();\n    }\n    return res;\n  };\n}\n\nconst isMac = cached(function () {\n  return testPlatform(/^Mac/i);\n});\n\nconst isIPhone = cached(function () {\n  return testPlatform(/^iPhone/i);\n});\n\nconst isIPad = cached(function () {\n  // iPadOS 13 lies and says it's a Mac, but we can distinguish by detecting touch support.\n  return testPlatform(/^iPad/i) || (isMac() && navigator.maxTouchPoints > 1);\n});\n\nexport const isIOS = cached(function () {\n  return isIPhone() || isIPad();\n});\n\n/** Wait for an element to be rendered and visible */\nexport function waitForElement(\n  className: string,\n  interval = 50,\n  maxAttempts = 20\n) {\n  return new Promise<HTMLElement | null>((resolve) => {\n    let attempts = 0;\n    const timer = setInterval(() => {\n      const element = document.getElementsByClassName(\n        className\n      )[0] as HTMLElement;\n      attempts++;\n      if (element || attempts >= maxAttempts) {\n        clearInterval(timer);\n        resolve(element);\n      }\n    }, interval);\n  });\n}\n", "import { type MotionStyle, motion } from 'motion/react';\nimport React, { forwardRef } from 'react';\n\nimport { useSheetContext } from './context';\nimport { styles } from './styles';\nimport { type SheetBackdropProps } from './types';\nimport { applyStyles } from './utils';\n\nconst isClickable = (props: any) => !!props.onClick || !!props.onTap;\n\nexport const SheetBackdrop = forwardRef<any, SheetBackdropProps>(\n  ({ style, className = '', unstyled, ...rest }, ref) => {\n    const sheetContext = useSheetContext();\n    const clickable = isClickable(rest);\n    const Comp = clickable ? motion.button : motion.div;\n    const pointerEvents = clickable ? 'auto' : 'none';\n\n    const isUnstyled = unstyled ?? sheetContext.unstyled;\n\n    const backdropStyle: MotionStyle = {\n      ...applyStyles(styles.backdrop, isUnstyled),\n      ...style,\n      pointerEvents,\n    };\n\n    return (\n      <Comp\n        {...(rest as any)}\n        ref={ref}\n        className={`react-modal-sheet-backdrop ${className}`}\n        style={backdropStyle}\n        initial={{ opacity: 0 }}\n        animate={{ opacity: 1 }}\n        exit={{ opacity: 0 }}\n        transition={{ duration: 1 }}\n      />\n    );\n  }\n);\n\nSheetBackdrop.displayName = 'SheetBackdrop';\n", "import { type MotionStyle, motion } from 'motion/react';\nimport React, { forwardRef } from 'react';\n\nimport { DEFAULT_HEIGHT } from './constants';\nimport { useSheetContext } from './context';\nimport { styles } from './styles';\nimport { type SheetContainerProps } from './types';\nimport { applyStyles, mergeRefs } from './utils';\n\nexport const SheetContainer = forwardRef<any, SheetContainerProps>(\n  ({ children, style, className = '', unstyled, ...rest }, ref) => {\n    const sheetContext = useSheetContext();\n\n    const isUnstyled = unstyled ?? sheetContext.unstyled;\n\n    const containerStyle: MotionStyle = {\n      ...applyStyles(styles.container, isUnstyled),\n      ...style,\n      y: sheetContext.y,\n    };\n\n    if (sheetContext.detent === 'default') {\n      containerStyle.height = DEFAULT_HEIGHT;\n    }\n\n    if (sheetContext.detent === 'full') {\n      containerStyle.height = '100%';\n      containerStyle.maxHeight = '100%';\n    }\n\n    if (sheetContext.detent === 'content') {\n      containerStyle.height = 'auto';\n      containerStyle.maxHeight = DEFAULT_HEIGHT;\n    }\n\n    return (\n      <motion.div\n        {...rest}\n        ref={mergeRefs([\n          ref,\n          sheetContext.sheetRef,\n          sheetContext.sheetBoundsRef,\n        ])}\n        className={`react-modal-sheet-container ${className}`}\n        style={containerStyle}\n      >\n        {children}\n      </motion.div>\n    );\n  }\n);\n\nSheetContainer.displayName = 'SheetContainer';\n", "import { useCallback, useRef } from 'react';\n\nimport { type BoundingBox } from 'motion/react';\n\n// This is a hacky way to fix a bug in motion/react where the drag\n// constraints are not updated when window is resized.\n// https://github.com/framer/motion/issues/1659\nconst constraints: BoundingBox = { bottom: 0, top: 0, left: 0, right: 0 };\n\nexport function useDragConstraints() {\n  const ref = useRef<any>(null);\n  const onMeasure = useCallback(() => constraints, []);\n  return { ref, onMeasure };\n}\n", "import { useEffect, useState } from 'react';\n\ntype UseScrollPositionOptions = {\n  /**\n   * Debounce delay in ms for scroll event handling.\n   * @default 32\n   */\n  debounceDelay?: number;\n  /**\n   * Enable or disable the hook entirely.\n   * @default true\n   */\n  isEnabled?: boolean;\n};\n\n/**\n * Hook to track the scroll position of an element.\n *\n * The scroll position can be 'top', 'bottom', 'middle', or undefined if the content is not scrollable.\n * The hook provides a `scrollRef` callback to assign to the scrollable element.\n *\n * Note that the scroll position is only updated when the user stops scrolling\n * for a short moment (debounced). You can set `debounceDelay` to `0` to disable debouncing entirely.\n *\n * @param options Configuration options for the hook.\n * @returns An object containing the `scrollRef` callback and the current `scrollPosition`.\n *\n * @example\n * ```tsx\n * import { useScrollPosition } from 'react-modal-sheet';\n *\n * function MyComponent() {\n *   const { scrollRef, scrollPosition } = useScrollPosition();\n *\n *   return (\n *     <div>\n *       <p>Scroll position: {scrollPosition}</p>\n *       <div ref={scrollRef} style={{ overflowY: 'auto', maxHeight: '300px' }}>\n *         ...long content...\n *       </div>\n *     </div>\n *   );\n * }\n * ```\n */\nexport function useScrollPosition(options: UseScrollPositionOptions = {}) {\n  const { debounceDelay = 32, isEnabled = true } = options;\n\n  const [element, setElement] = useState<HTMLElement | null>(null);\n  const [scrollPosition, setScrollPosition] = useState<\n    'top' | 'bottom' | 'middle' | undefined\n  >(undefined);\n\n  useEffect(() => {\n    if (!element || !isEnabled) return;\n\n    let scrollTimeout: number | null = null;\n\n    function determineScrollPosition(element: HTMLElement) {\n      const { scrollTop, scrollHeight, clientHeight } = element;\n      const isScrollable = scrollHeight > clientHeight;\n\n      if (!isScrollable) {\n        // Reset scroll position if the content is not scrollable anymore\n        if (scrollPosition) setScrollPosition(undefined);\n        return;\n      }\n\n      const isAtTop = scrollTop <= 0;\n      const isAtBottom =\n        Math.ceil(scrollHeight) - Math.ceil(scrollTop) ===\n        Math.ceil(clientHeight);\n\n      let position: 'top' | 'bottom' | 'middle';\n\n      if (isAtTop) {\n        position = 'top';\n      } else if (isAtBottom) {\n        position = 'bottom';\n      } else {\n        position = 'middle';\n      }\n\n      if (position === scrollPosition) return;\n      setScrollPosition(position);\n    }\n\n    function onScroll(event: Event) {\n      if (event.currentTarget instanceof HTMLElement) {\n        const el = event.currentTarget;\n\n        if (scrollTimeout) clearTimeout(scrollTimeout);\n\n        if (debounceDelay === 0) {\n          determineScrollPosition(el);\n        } else {\n          // Debounce the scroll handler\n          scrollTimeout = setTimeout(\n            () => determineScrollPosition(el),\n            debounceDelay\n          );\n        }\n      }\n    }\n\n    function onTouchStart(event: Event) {\n      if (event.currentTarget instanceof HTMLElement) {\n        determineScrollPosition(event.currentTarget);\n      }\n    }\n\n    // Determine initial scroll position\n    determineScrollPosition(element);\n\n    element.addEventListener('scroll', onScroll);\n    element.addEventListener('touchstart', onTouchStart);\n\n    return () => {\n      if (scrollTimeout) clearTimeout(scrollTimeout);\n      element.removeEventListener('scroll', onScroll);\n      element.removeEventListener('touchstart', onTouchStart);\n    };\n  }, [element, isEnabled]);\n\n  return {\n    scrollRef: (element: HTMLElement | null) => setElement(element),\n    scrollPosition,\n  };\n}\n", "import { type MotionStyle, motion } from 'motion/react';\nimport React, { forwardRef } from 'react';\n\nimport { useSheetContext } from './context';\nimport { useDragConstraints } from './hooks/use-drag-constraints';\nimport { useScrollPosition } from './hooks/use-scroll-position';\nimport { styles } from './styles';\nimport { type SheetContentProps } from './types';\nimport { applyStyles, mergeRefs } from './utils';\n\nexport const SheetContent = forwardRef<any, SheetContentProps>(\n  (\n    {\n      disableScroll: disableScrollProp,\n      disableDrag: disableDragProp,\n      children,\n      style: styleProp,\n      className = '',\n      scrollClassName = '',\n      scrollStyle: scrollStyleProp,\n      scrollRef: scrollRefProp = null,\n      unstyled,\n      ...rest\n    },\n    ref\n  ) => {\n    const sheetContext = useSheetContext();\n    const dragConstraints = useDragConstraints();\n    const scroll = useScrollPosition();\n\n    const disableScroll =\n      typeof disableScrollProp === 'function'\n        ? disableScrollProp({\n            scrollPosition: scroll.scrollPosition,\n            currentSnap: sheetContext.currentSnap,\n          })\n        : Boolean(disableScrollProp);\n\n    const disableDragDueToScroll =\n      !disableScroll &&\n      scroll.scrollPosition &&\n      scroll.scrollPosition !== 'top';\n\n    const disableDragDueToProp =\n      typeof disableDragProp === 'function'\n        ? disableDragProp({\n            scrollPosition: scroll.scrollPosition,\n            currentSnap: sheetContext.currentSnap,\n          })\n        : Boolean(disableDragProp);\n\n    const disableDrag =\n      disableDragDueToProp ||\n      disableDragDueToScroll ||\n      sheetContext.disableDrag;\n\n    const dragProps =\n      disableDrag || sheetContext.disableDrag\n        ? undefined\n        : sheetContext.dragProps;\n\n    const isUnstyled = unstyled ?? sheetContext.unstyled;\n\n    const contentStyle: MotionStyle = {\n      ...applyStyles(styles.content, isUnstyled),\n      ...styleProp,\n    };\n\n    const scrollStyle: MotionStyle = applyStyles(styles.scroller, isUnstyled);\n\n    if (sheetContext.avoidKeyboard) {\n      scrollStyle.paddingBottom =\n        'env(keyboard-inset-height, var(--keyboard-inset-height, 0px))';\n    }\n\n    if (disableScroll) {\n      scrollStyle.overflowY = 'hidden';\n    }\n\n    return (\n      <motion.div\n        {...rest}\n        ref={mergeRefs([ref, dragConstraints.ref])}\n        className={`react-modal-sheet-content ${className}`}\n        style={contentStyle}\n        {...dragProps}\n        dragConstraints={dragConstraints.ref}\n        onMeasureDragConstraints={dragConstraints.onMeasure}\n      >\n        <motion.div\n          ref={mergeRefs([scroll.scrollRef, scrollRefProp])}\n          style={{ ...scrollStyle, ...scrollStyleProp }}\n          className={`react-modal-sheet-content-scroller ${scrollClassName}`}\n        >\n          {children}\n        </motion.div>\n      </motion.div>\n    );\n  }\n);\n\nSheetContent.displayName = 'SheetContent';\n", "import { motion, useTransform } from 'motion/react';\nimport React from 'react';\n\nimport { useSheetContext } from './context';\nimport { styles } from './styles';\nimport type { SheetDragIndicatorProps } from './types';\nimport { applyStyles } from './utils';\n\nexport function SheetDragIndicator({\n  style,\n  className = '',\n  unstyled,\n  ...rest\n}: SheetDragIndicatorProps) {\n  const sheetContext = useSheetContext();\n\n  const indicator1Transform = useTransform(\n    sheetContext.indicatorRotation,\n    (r) => `translateX(2px) rotate(${r}deg)`\n  );\n\n  const indicator2Transform = useTransform(\n    sheetContext.indicatorRotation,\n    (r) => `translateX(-2px) rotate(${-1 * r}deg)`\n  );\n\n  const isUnstyled = unstyled ?? sheetContext.unstyled;\n\n  const indicatorWrapperStyle = {\n    ...applyStyles(styles.indicatorWrapper, isUnstyled),\n    ...style,\n  };\n\n  const indicatorStyle = applyStyles(styles.indicator, isUnstyled);\n\n  return (\n    <div\n      className={`react-modal-sheet-drag-indicator-container ${className}`}\n      style={indicatorWrapperStyle}\n      {...rest}\n    >\n      <motion.span\n        className=\"react-modal-sheet-drag-indicator\"\n        style={{ ...indicatorStyle, transform: indicator1Transform }}\n      />\n      <motion.span\n        className=\"react-modal-sheet-drag-indicator\"\n        style={{ ...indicatorStyle, transform: indicator2Transform }}\n      />\n    </div>\n  );\n}\n", "import { motion } from 'motion/react';\nimport React, { forwardRef } from 'react';\n\nimport { SheetDragIndicator } from './SheetDragIndicator';\nimport { useSheetContext } from './context';\nimport { useDragConstraints } from './hooks/use-drag-constraints';\nimport { styles } from './styles';\nimport { type SheetHeaderProps } from './types';\nimport { applyStyles, mergeRefs } from './utils';\n\nexport const SheetHeader = forwardRef<any, SheetHeaderProps>(\n  (\n    { children, style, disableDrag, unstyled, className = '', ...rest },\n    ref\n  ) => {\n    const sheetContext = useSheetContext();\n    const dragConstraints = useDragConstraints();\n    const dragProps =\n      disableDrag || sheetContext.disableDrag\n        ? undefined\n        : sheetContext.dragProps;\n\n    const isUnstyled = unstyled ?? sheetContext.unstyled;\n\n    const headerWrapperStyle = {\n      ...applyStyles(styles.headerWrapper, isUnstyled),\n      ...style,\n    };\n\n    const headerStyle = applyStyles(styles.header, isUnstyled);\n\n    return (\n      <motion.div\n        {...rest}\n        ref={mergeRefs([ref, dragConstraints.ref])}\n        style={headerWrapperStyle}\n        className={`react-modal-sheet-header-container ${className}`}\n        {...dragProps}\n        dragConstraints={dragConstraints.ref}\n        onMeasureDragConstraints={dragConstraints.onMeasure}\n      >\n        {children || (\n          <div className=\"react-modal-sheet-header\" style={headerStyle}>\n            <SheetDragIndicator />\n          </div>\n        )}\n      </motion.div>\n    );\n  }\n);\n\nSheetHeader.displayName = 'SheetHeader';\n", "import { useEffect, useLayoutEffect } from 'react';\n\nimport { IS_SSR } from '../constants';\n\nexport const useIsomorphicLayoutEffect = IS_SSR ? useEffect : useLayoutEffect;\n", "import { useState } from 'react';\n\nimport { IS_SSR } from '../constants';\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect';\n\nexport function useDimensions() {\n  const [dimensions, setDimensions] = useState(() => ({\n    windowHeight: !IS_SSR ? window.innerHeight : 0,\n    windowWidth: !IS_SSR ? window.innerWidth : 0,\n  }));\n\n  useIsomorphicLayoutEffect(() => {\n    function handler() {\n      setDimensions({\n        windowHeight: window.innerHeight,\n        windowWidth: window.innerWidth,\n      });\n    }\n\n    handler();\n\n    window.addEventListener('resize', handler);\n\n    return () => {\n      window.removeEventListener('resize', handler);\n    };\n  }, []);\n\n  return dimensions;\n}\n", "import { useState } from 'react';\n\nimport { IS_SSR } from '../constants';\n\nexport function useSafeAreaInsets() {\n  const [insets] = useState(() => {\n    const fallback = { top: 0, left: 0, right: 0, bottom: 0 };\n\n    if (IS_SSR) return fallback;\n\n    const root = document.querySelector<HTMLElement>(':root');\n\n    if (!root) return fallback;\n\n    root.style.setProperty('--rms-sat', 'env(safe-area-inset-top)');\n    root.style.setProperty('--rms-sal', 'env(safe-area-inset-left)');\n    root.style.setProperty('--rms-sar', 'env(safe-area-inset-right)');\n    root.style.setProperty('--rms-sab', 'env(safe-area-inset-bottom)');\n\n    const computedStyle = getComputedStyle(root);\n    const sat = getComputedValue(computedStyle, '--rms-sat');\n    const sal = getComputedValue(computedStyle, '--rms-sal');\n    const sar = getComputedValue(computedStyle, '--rms-sar');\n    const sab = getComputedValue(computedStyle, '--rms-sab');\n\n    root.style.removeProperty('--rms-sat');\n    root.style.removeProperty('--rms-sal');\n    root.style.removeProperty('--rms-sar');\n    root.style.removeProperty('--rms-sab');\n\n    return { top: sat, left: sal, right: sar, bottom: sab };\n  });\n\n  return insets;\n}\n\nfunction getComputedValue(computed: CSSStyleDeclaration, property: string) {\n  const strValue = computed.getPropertyValue(property).replace('px', '').trim();\n  return parseInt(strValue, 10) || 0;\n}\n", "import { type MotionValue, transform } from 'motion';\nimport { type RefObject } from 'react';\n\nimport type { SheetDetent, SheetSnapPoint } from '../types';\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect';\nimport { useSafeAreaInsets } from './use-safe-area-insets';\n\nexport function useModalEffect({\n  y,\n  detent,\n  rootId: _rootId,\n  sheetHeight,\n  snapPoints,\n  startThreshold,\n}: {\n  y: MotionValue<number>;\n  detent: SheetDetent;\n  rootId?: string;\n  sheetHeight: number;\n  snapPoints: SheetSnapPoint[];\n  startThreshold?: number;\n}) {\n  const insetTop = useSafeAreaInsets().top;\n\n  let rootId: string | undefined = _rootId;\n\n  if (rootId && detent === 'full') {\n    console.warn('Using \"full\" detent with modal effect is not supported.');\n    rootId = undefined;\n  }\n\n  // Cleanup on unmount\n  useIsomorphicLayoutEffect(() => {\n    return () => {\n      if (rootId) cleanupModalEffect(rootId);\n    };\n  }, []);\n\n  useIsomorphicLayoutEffect(() => {\n    if (!rootId) return;\n\n    const root = document.querySelector(`#${rootId}`) as HTMLDivElement;\n    if (!root) return;\n\n    const removeStartListener = y.on('animationStart', () => {\n      // biome-ignore lint/style/noNonNullAssertion: root is always defined here\n      setupModalEffect(rootId!);\n    });\n\n    /**\n     * NOTE: The `y` value gets smaller when the sheet is opened and larger\n     * when the sheet is being closed.\n     */\n    const removeChangeListener = y.on('change', (yValue) => {\n      if (!root) return;\n\n      let progress = Math.max(0, 1 - yValue / sheetHeight);\n\n      /**\n       * Start the effect only if we have dragged over the second snap point\n       * to make the effect more natural as the sheet will reach it's final\n       * position when the user drags it over the second snap point.\n       */\n      const snapThresholdPoint =\n        snapPoints.length > 1 ? snapPoints[snapPoints.length - 2] : undefined;\n\n      /**\n       * If we have snap points, we need to calculate the progress percentage\n       * based on the snap point threshold. Note that the maximum value is also\n       * different in this case as the range between the start of the effect\n       * and its end is different.\n       */\n      if (snapThresholdPoint !== undefined) {\n        const snapThresholdValue = snapThresholdPoint.snapValueY;\n\n        if (yValue <= snapThresholdValue) {\n          progress = (snapThresholdValue - yValue) / snapThresholdValue;\n        } else {\n          progress = 0;\n        }\n      }\n\n      /**\n       * If we have a start threshold, we need to calculate the progress\n       * percentage based on the start threshold (0 to 1). For example,\n       * if the start threshold is 0.5, the progress will be 0 until the sheet\n       * is dragged over 50% of the complete drag distance.\n       */\n      if (startThreshold !== undefined) {\n        const startThresholdValue =\n          sheetHeight -\n          Math.min(Math.floor(startThreshold * sheetHeight), sheetHeight);\n\n        if (yValue <= startThresholdValue) {\n          progress = (startThresholdValue - yValue) / startThresholdValue;\n        } else {\n          progress = 0;\n        }\n      }\n\n      // Make sure progress is between 0 and 1\n      progress = Math.max(0, Math.min(1, progress));\n\n      const pageWidth = window.innerWidth;\n      const ty = transform(progress, [0, 1], [0, 24 + insetTop]);\n      const s = transform(progress, [0, 1], [1, (pageWidth - 16) / pageWidth]);\n      const borderRadius = transform(progress, [0, 1], [0, 10]);\n\n      root.style.transform = `scale(${s}) translate3d(0, ${ty}px, 0)`;\n      root.style.borderTopRightRadius = `${borderRadius}px`;\n      root.style.borderTopLeftRadius = `${borderRadius}px`;\n    });\n\n    function onCompleted() {\n      // -5 just to take into account some inprecision to ensure the cleanup is done\n      if (y.get() - 5 >= sheetHeight) {\n        // biome-ignore lint/style/noNonNullAssertion: root is always defined here\n        cleanupModalEffect(rootId!);\n      }\n    }\n\n    const removeCompleteListener = y.on('animationComplete', onCompleted);\n    const removeCancelListener = y.on('animationCancel', onCompleted);\n\n    return () => {\n      removeStartListener();\n      removeChangeListener();\n      removeCompleteListener();\n      removeCancelListener();\n    };\n  }, [y, rootId, insetTop, startThreshold, sheetHeight]);\n}\n\nfunction setupModalEffect(rootId: string) {\n  const root = document.querySelector(`#${rootId}`) as HTMLDivElement;\n  const body = document.querySelector('body') as HTMLBodyElement;\n  if (!root) return;\n\n  body.style.backgroundColor = '#000';\n  root.style.overflow = 'hidden';\n  root.style.transitionTimingFunction = 'cubic-bezier(0.32, 0.72, 0, 1)';\n  root.style.transitionProperty = 'transform, border-radius';\n  root.style.transitionDuration = '0.5s';\n  root.style.transformOrigin = 'center top';\n}\n\nfunction cleanupModalEffect(rootId: string) {\n  const root = document.querySelector(`#${rootId}`) as HTMLDivElement;\n  const body = document.querySelector('body') as HTMLBodyElement;\n  if (!root) return;\n\n  body.style.removeProperty('background-color');\n  root.style.removeProperty('overflow');\n  root.style.removeProperty('transition-timing-function');\n  root.style.removeProperty('transition-property');\n  root.style.removeProperty('transition-duration');\n  root.style.removeProperty('transform-origin');\n  root.style.removeProperty('transform');\n  root.style.removeProperty('border-top-right-radius');\n  root.style.removeProperty('border-top-left-radius');\n}\n", "// This code originates from https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/overlays/src/usePreventScroll.ts\n\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect';\nimport { isIOS } from '../utils';\n\nconst KEYBOARD_BUFFER = 24;\n\ninterface PreventScrollOptions {\n  /** Whether the scroll lock is disabled. */\n  isDisabled?: boolean;\n}\n\nfunction chain(...callbacks: any[]): (...args: any[]) => void {\n  return (...args: any[]) => {\n    for (const callback of callbacks) {\n      if (typeof callback === 'function') {\n        callback(...args);\n      }\n    }\n  };\n}\n\nconst visualViewport = typeof document !== 'undefined' && window.visualViewport;\n\nexport function isScrollable(\n  node: Element | null,\n  checkForOverflow?: boolean\n): boolean {\n  if (!node) {\n    return false;\n  }\n\n  const style = window.getComputedStyle(node);\n\n  let isScrollable = /(auto|scroll)/.test(\n    style.overflow + style.overflowX + style.overflowY\n  );\n\n  if (isScrollable && checkForOverflow) {\n    isScrollable =\n      node.scrollHeight !== node.clientHeight ||\n      node.scrollWidth !== node.clientWidth;\n  }\n\n  return isScrollable;\n}\n\nexport function getScrollParent(\n  node: Element,\n  checkForOverflow?: boolean\n): Element {\n  let scrollableNode: Element | null = node;\n\n  if (isScrollable(scrollableNode, checkForOverflow)) {\n    scrollableNode = scrollableNode.parentElement;\n  }\n\n  while (scrollableNode && !isScrollable(scrollableNode, checkForOverflow)) {\n    scrollableNode = scrollableNode.parentElement;\n  }\n\n  return (\n    scrollableNode || document.scrollingElement || document.documentElement\n  );\n}\n\n// HTML input types that do not cause the software keyboard to appear.\nconst nonTextInputTypes = new Set([\n  'checkbox',\n  'radio',\n  'range',\n  'color',\n  'file',\n  'image',\n  'button',\n  'submit',\n  'reset',\n]);\n\n// The number of active usePreventScroll calls. Used to determine whether to revert back to the original page style/scroll position\nlet preventScrollCount = 0;\nlet restore: () => void;\n\n/**\n * Prevents scrolling on the document body on mount, and\n * restores it on unmount. Also ensures that content does not\n * shift due to the scrollbars disappearing.\n */\nexport function usePreventScroll(options: PreventScrollOptions = {}) {\n  const { isDisabled } = options;\n\n  useIsomorphicLayoutEffect(() => {\n    if (isDisabled) {\n      return;\n    }\n\n    preventScrollCount++;\n    if (preventScrollCount === 1) {\n      if (isIOS()) {\n        restore = preventScrollMobileSafari();\n      } else {\n        restore = preventScrollStandard();\n      }\n    }\n\n    return () => {\n      preventScrollCount--;\n      if (preventScrollCount === 0) {\n        restore?.();\n      }\n    };\n  }, [isDisabled]);\n}\n\n// For most browsers, all we need to do is set `overflow: hidden` on the root element, and\n// add some padding to prevent the page from shifting when the scrollbar is hidden.\nfunction preventScrollStandard() {\n  return chain(\n    setStyle(\n      document.documentElement,\n      'paddingRight',\n      `${window.innerWidth - document.documentElement.clientWidth}px`\n    ),\n    setStyle(document.documentElement, 'overflow', 'hidden')\n  );\n}\n\n// Mobile Safari is a whole different beast. Even with overflow: hidden,\n// it still scrolls the page in many situations:\n//\n// 1. When the bottom toolbar and address bar are collapsed, page scrolling is always allowed.\n// 2. When the keyboard is visible, the viewport does not resize. Instead, the keyboard covers part of\n//    it, so it becomes scrollable.\n// 3. When tapping on an input, the page always scrolls so that the input is centered in the visual viewport.\n//    This may cause even fixed position elements to scroll off the screen.\n// 4. When using the next/previous buttons in the keyboard to navigate between inputs, the whole page always\n//    scrolls, even if the input is inside a nested scrollable element that could be scrolled instead.\n//\n// In order to work around these cases, and prevent scrolling without jankiness, we do a few things:\n//\n// 1. Prevent default on `touchmove` events that are not in a scrollable element. This prevents touch scrolling\n//    on the window.\n// 2. Prevent default on `touchmove` events inside a scrollable element when the scroll position is at the\n//    top or bottom. This avoids the whole page scrolling instead, but does prevent overscrolling.\n// 3. Prevent default on `touchend` events on input elements and handle focusing the element ourselves.\n// 4. When focusing an input, apply a transform to trick Safari into thinking the input is at the top\n//    of the page, which prevents it from scrolling the page. After the input is focused, scroll the element\n//    into view ourselves, without scrolling the whole page.\n// 5. Offset the body by the scroll position using a negative margin and scroll to the top. This should appear the\n//    same visually, but makes the actual scroll position always zero. This is required to make all of the\n//    above work or Safari will still try to scroll the page when focusing an input.\n// 6. As a last resort, handle window scroll events, and scroll back to the top. This can happen when attempting\n//    to navigate to an input with the next/previous buttons that's outside a modal.\nfunction preventScrollMobileSafari() {\n  let scrollable: Element | undefined;\n  let lastY = 0;\n\n  const onTouchStart = (e: TouchEvent) => {\n    // Use `composedPath` to support shadow DOM.\n    const target = e.composedPath()?.[0] as HTMLElement;\n\n    // Store the nearest scrollable parent element from the element that the user touched.\n    scrollable = getScrollParent(target, true);\n\n    if (\n      scrollable === document.documentElement &&\n      scrollable === document.body\n    ) {\n      return;\n    }\n\n    lastY = e.changedTouches[0].pageY;\n  };\n\n  const onTouchMove = (e: TouchEvent) => {\n    // In special situations, `onTouchStart` may be called without `onTouchStart` being called.\n    // (e.g. when the user places a finger on the screen before the <Sheet> is mounted and then moves the finger after it is mounted).\n    // If `onTouchStart` is not called, `scrollable` is `undefined`. Therefore, such cases are ignored.\n    if (scrollable === undefined) {\n      return;\n    }\n\n    // Prevent scrolling the window.\n    if (\n      !scrollable ||\n      scrollable === document.documentElement ||\n      scrollable === document.body\n    ) {\n      e.preventDefault();\n      return;\n    }\n\n    // Prevent scrolling up when at the top and scrolling down when at the bottom\n    // of a nested scrollable area, otherwise mobile Safari will start scrolling\n    // the window instead. Unfortunately, this disables bounce scrolling when at\n    // the top but it's the best we can do.\n    const y = e.changedTouches[0].pageY;\n    const scrollTop = scrollable.scrollTop;\n    const bottom = scrollable.scrollHeight - scrollable.clientHeight;\n\n    if (bottom === 0) {\n      return;\n    }\n\n    if ((scrollTop <= 0 && y > lastY) || (scrollTop >= bottom && y < lastY)) {\n      e.preventDefault();\n    }\n\n    lastY = y;\n  };\n\n  const onTouchEnd = (e: TouchEvent) => {\n    // Use `composedPath` to support shadow DOM.\n    const target = e.composedPath()?.[0] as HTMLElement;\n\n    // Apply this change if we're not already focused on the target element\n    if (willOpenKeyboard(target) && target !== document.activeElement) {\n      e.preventDefault();\n\n      // Apply a transform to trick Safari into thinking the input is at the top of the page\n      // so it doesn't try to scroll it into view. When tapping on an input, this needs to\n      // be done before the \"focus\" event, so we have to focus the element ourselves.\n      target.style.transform = 'translateY(-2000px)';\n      target.focus();\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n      });\n    }\n  };\n\n  const onFocus = (e: FocusEvent) => {\n    // Use `composedPath` to support shadow DOM.\n    const target = e.composedPath()?.[0] as HTMLElement;\n\n    if (willOpenKeyboard(target)) {\n      // Transform also needs to be applied in the focus event in cases where focus moves\n      // other than tapping on an input directly, e.g. the next/previous buttons in the\n      // software keyboard. In these cases, it seems applying the transform in the focus event\n      // is good enough, whereas when tapping an input, it must be done before the focus event. ðŸ¤·â€â™‚ï¸\n      target.style.transform = 'translateY(-2000px)';\n      requestAnimationFrame(() => {\n        target.style.transform = '';\n\n        // This will have prevented the browser from scrolling the focused element into view,\n        // so we need to do this ourselves in a way that doesn't cause the whole page to scroll.\n        if (visualViewport) {\n          if (visualViewport.height < window.innerHeight) {\n            // If the keyboard is already visible, do this after one additional frame\n            // to wait for the transform to be removed.\n            requestAnimationFrame(() => {\n              scrollIntoView(target);\n            });\n          } else {\n            // Otherwise, wait for the visual viewport to resize before scrolling so we can\n            // measure the correct position to scroll to.\n            visualViewport.addEventListener(\n              'resize',\n              () => scrollIntoView(target),\n              { once: true }\n            );\n          }\n        }\n      });\n    }\n  };\n\n  const onWindowScroll = () => {\n    // Last resort. If the window scrolled, scroll it back to the top.\n    // It should always be at the top because the body will have a negative margin (see below).\n    window.scrollTo(0, 0);\n  };\n\n  // Record the original scroll position so we can restore it.\n  // Then apply a negative margin to the body to offset it by the scroll position. This will\n  // enable us to scroll the window to the top, which is required for the rest of this to work.\n  const scrollX = window.pageXOffset;\n  const scrollY = window.pageYOffset;\n\n  const restoreStyles = chain(\n    setStyle(\n      document.documentElement,\n      'paddingRight',\n      `${window.innerWidth - document.documentElement.clientWidth}px`\n    ),\n    setStyle(document.documentElement, 'overflow', 'hidden'),\n    setStyle(document.body, 'marginTop', `-${scrollY}px`)\n  );\n\n  // Scroll to the top. The negative margin on the body will make this appear the same.\n  window.scrollTo(0, 0);\n\n  const removeEvents = chain(\n    addEvent(document, 'touchstart', onTouchStart, {\n      passive: false,\n      capture: true,\n    }),\n    addEvent(document, 'touchmove', onTouchMove, {\n      passive: false,\n      capture: true,\n    }),\n    addEvent(document, 'touchend', onTouchEnd, {\n      passive: false,\n      capture: true,\n    }),\n    addEvent(document, 'focus', onFocus, true),\n    addEvent(window, 'scroll', onWindowScroll)\n  );\n\n  return () => {\n    // Restore styles and scroll the page back to where it was.\n    restoreStyles();\n    removeEvents();\n    window.scrollTo(scrollX, scrollY);\n  };\n}\n\n// Sets a CSS property on an element, and returns a function to revert it to the previous value.\nfunction setStyle(element: any, style: string, value: string) {\n  // https://github.com/microsoft/TypeScript/issues/17827#issuecomment-391663310\n  const cur = element.style[style];\n  element.style[style] = value;\n\n  return () => {\n    element.style[style] = cur;\n  };\n}\n\n// Adds an event listener to an element, and returns a function to remove it.\nfunction addEvent<K extends keyof GlobalEventHandlersEventMap>(\n  target: EventTarget,\n  event: K,\n  handler: (this: Document, ev: GlobalEventHandlersEventMap[K]) => any,\n  options?: boolean | AddEventListenerOptions\n) {\n  // @ts-expect-error\n  target.addEventListener(event, handler, options);\n\n  return () => {\n    // @ts-expect-error\n    target.removeEventListener(event, handler, options);\n  };\n}\n\nfunction scrollIntoView(target: Element) {\n  const root = document.scrollingElement || document.documentElement;\n  while (target && target !== root) {\n    // Find the parent scrollable element and adjust the scroll position if the target is not already in view.\n    const scrollable = getScrollParent(target);\n    if (\n      scrollable !== document.documentElement &&\n      scrollable !== document.body &&\n      scrollable !== target\n    ) {\n      const scrollableTop = scrollable.getBoundingClientRect().top;\n      const targetTop = target.getBoundingClientRect().top;\n      const targetBottom = target.getBoundingClientRect().bottom;\n      // Buffer is needed for some edge cases\n      const keyboardHeight =\n        scrollable.getBoundingClientRect().bottom + KEYBOARD_BUFFER;\n\n      if (targetBottom > keyboardHeight) {\n        scrollable.scrollTop += targetTop - scrollableTop;\n      }\n    }\n\n    // @ts-expect-error\n    target = scrollable.parentElement;\n  }\n}\n\nfunction willOpenKeyboard(target: Element) {\n  return (\n    (target instanceof HTMLInputElement &&\n      !nonTextInputTypes.has(target.type)) ||\n    target instanceof HTMLTextAreaElement ||\n    (target instanceof HTMLElement && target.isContentEditable)\n  );\n}\n", "import { useCallback, useRef } from 'react';\n\nimport { useIsomorphicLayoutEffect } from './use-isomorphic-layout-effect';\n\nexport function useStableCallback<T extends (...args: any[]) => any>(\n  handler: T\n) {\n  const handlerRef = useRef<T>(undefined);\n\n  useIsomorphicLayoutEffect(() => {\n    handlerRef.current = handler;\n  });\n\n  return useCallback((...args: any[]) => {\n    const fn = handlerRef.current;\n    return fn?.(...args);\n  }, []) as T;\n}\n", "import { useEffect, useState } from 'react';\nimport { useStableCallback } from './use-stable-callback';\n\ntype SheetState = 'closed' | 'opening' | 'open' | 'closing';\n\ntype UseSheetStatesProps = {\n  isOpen: boolean;\n  onClosed?: () => Promise<void> | void;\n  onOpening?: () => Promise<void> | void;\n  onOpen?: () => Promise<void> | void;\n  onClosing?: () => Promise<void> | void;\n};\n\nexport function useSheetState({\n  isOpen,\n  onClosed: _onClosed,\n  onOpening: _onOpening,\n  onOpen: _onOpen,\n  onClosing: _onClosing,\n}: UseSheetStatesProps) {\n  const [state, setState] = useState<SheetState>(isOpen ? 'opening' : 'closed');\n  const onClosed = useStableCallback(() => _onClosed?.());\n  const onOpening = useStableCallback(() => _onOpening?.());\n  const onOpen = useStableCallback(() => _onOpen?.());\n  const onClosing = useStableCallback(() => _onClosing?.());\n\n  useEffect(() => {\n    if (isOpen && state === 'closed') {\n      setState('opening');\n    } else if (!isOpen && (state === 'open' || state === 'opening')) {\n      setState('closing');\n    }\n  }, [isOpen, state]);\n\n  useEffect(() => {\n    async function handle() {\n      switch (state) {\n        case 'closed':\n          await onClosed?.();\n          break;\n\n        case 'opening':\n          await onOpening?.();\n          setState('open');\n          break;\n\n        case 'open':\n          await onOpen?.();\n          break;\n\n        case 'closing':\n          await onClosing?.();\n          setState('closed');\n          break;\n      }\n    }\n    handle().catch((error) => {\n      console.error('Internal sheet state error:', error);\n    });\n  }, [state]);\n\n  return state;\n}\n", "import { type RefObject, useEffect, useRef, useState } from 'react';\nimport { useStableCallback } from './use-stable-callback';\n\ntype VirtualKeyboardState = {\n  isVisible: boolean;\n  height: number;\n};\n\ntype UseVirtualKeyboardOptions = {\n  /**\n   * Ref to the container element to apply `keyboard-inset-height` CSS variable updates.\n   * @default document.documentElement\n   */\n  containerRef?: RefObject<HTMLElement | null>;\n  /**\n   * Enable or disable the hook entirely.\n   * @default true\n   */\n  isEnabled?: boolean;\n  /**\n   * Minimum pixel height difference to consider the keyboard visible.\n   * @default 100\n   */\n  visualViewportThreshold?: number;\n  /**\n   * Whether to treat contenteditable elements as text inputs.\n   * @default true\n   */\n  includeContentEditable?: boolean;\n  /**\n   * Delay in ms for debouncing viewport changes.\n   * @default 100\n   */\n  debounceDelay?: number;\n};\n\n/**\n * A hook that detects virtual keyboard visibility and height.\n * It listens to focus events and visual viewport changes to determine\n * if a text input is focused and the keyboard is likely visible.\n *\n * It also sets the `--keyboard-inset-height` CSS variable on the specified container\n * (or `:root` by default) to allow for easy styling adjustments when the keyboard is open.\n *\n * @param options Configuration options for the hook.\n * @returns An object containing `isKeyboardOpen` and `keyboardHeight`.\n *\n * @example\n * ```tsx\n * import { useVirtualKeyboard } from 'react-modal-sheet';\n *\n * function MyComponent() {\n *   const { isKeyboardOpen, keyboardHeight } = useVirtualKeyboard();\n *\n *   return (\n *     <div>\n *       <p>Keyboard is {isKeyboardOpen ? 'open' : 'closed'}</p>\n *       <p>Keyboard height: {keyboardHeight}px</p>\n *    </div>\n *  );\n * }\n * ```\n */\nexport function useVirtualKeyboard(options: UseVirtualKeyboardOptions = {}) {\n  const {\n    containerRef,\n    isEnabled = true,\n    debounceDelay = 100,\n    includeContentEditable = true,\n    visualViewportThreshold = 100,\n  } = options;\n\n  const [state, setState] = useState<VirtualKeyboardState>({\n    isVisible: false,\n    height: 0,\n  });\n\n  const focusedElementRef = useRef<HTMLElement | null>(null);\n  const debounceTimer = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  const isTextInput = useStableCallback((el: Element | null) => {\n    return (\n      el?.tagName === 'INPUT' ||\n      el?.tagName === 'TEXTAREA' ||\n      (includeContentEditable &&\n        el instanceof HTMLElement &&\n        el.isContentEditable)\n    );\n  });\n\n  useEffect(() => {\n    if (!isEnabled) return;\n\n    const vv = window.visualViewport;\n    const vk = (navigator as any).virtualKeyboard;\n\n    function setKeyboardInsetHeightEnv(height: number) {\n      const element = containerRef?.current || document.documentElement;\n\n      // Virtual Keyboard API is only available in secure context\n      if (window.isSecureContext) {\n        element.style.setProperty(\n          '--keyboard-inset-height',\n          `env(keyboard-inset-height, ${height}px)`\n        );\n      } else {\n        element.style.setProperty('--keyboard-inset-height', `${height}px`);\n      }\n    }\n\n    function handleFocusIn(e: FocusEvent) {\n      if (e.target instanceof HTMLElement && isTextInput(e.target)) {\n        focusedElementRef.current = e.target;\n        updateKeyboardState();\n      }\n    }\n\n    function handleFocusOut() {\n      focusedElementRef.current = null;\n      updateKeyboardState();\n    }\n\n    function updateKeyboardState() {\n      if (debounceTimer.current) {\n        clearTimeout(debounceTimer.current);\n      }\n      debounceTimer.current = setTimeout(() => {\n        const active = focusedElementRef.current;\n        const inputIsFocused = isTextInput(active);\n\n        if (!inputIsFocused) {\n          setKeyboardInsetHeightEnv(0);\n          setState({ isVisible: false, height: 0 });\n          return;\n        }\n\n        if (vv) {\n          const heightDiff = window.innerHeight - vv.height;\n\n          if (heightDiff > visualViewportThreshold) {\n            setKeyboardInsetHeightEnv(heightDiff);\n            setState({ isVisible: true, height: heightDiff });\n          } else {\n            setKeyboardInsetHeightEnv(0);\n            setState({ isVisible: false, height: 0 });\n          }\n        }\n      }, debounceDelay);\n    }\n\n    window.addEventListener('focusin', handleFocusIn);\n    window.addEventListener('focusout', handleFocusOut);\n\n    if (vv) {\n      vv.addEventListener('resize', updateKeyboardState);\n      vv.addEventListener('scroll', updateKeyboardState);\n    }\n\n    let currentOverlaysContent = false;\n\n    if (vk) {\n      currentOverlaysContent = vk.overlaysContent;\n      vk.overlaysContent = true;\n    }\n\n    return () => {\n      window.removeEventListener('focusin', handleFocusIn);\n      window.removeEventListener('focusout', handleFocusOut);\n\n      if (vv) {\n        vv.removeEventListener('resize', updateKeyboardState);\n        vv.removeEventListener('scroll', updateKeyboardState);\n      }\n\n      if (vk) {\n        vk.overlaysContent = currentOverlaysContent;\n      }\n\n      if (debounceTimer.current) {\n        clearTimeout(debounceTimer.current);\n      }\n    };\n  }, [\n    debounceDelay,\n    includeContentEditable,\n    isEnabled,\n    visualViewportThreshold,\n  ]);\n\n  return {\n    keyboardHeight: state.height,\n    isKeyboardOpen: state.isVisible,\n  };\n}\n", "import type { SheetSnapPoint } from './types';\nimport { isAscendingOrder } from './utils';\n\n/**\n * Convert negative / percentage snap points to absolute values\n *\n * Example output:\n *\n * ```json\n * [\n *     {\n *         \"snapIndex\": 0, // <-- bottom snap point\n *         \"snapValue\": 0,\n *         \"snapValueY\": 810\n *     },\n *     {\n *         \"snapIndex\": 1,\n *         \"snapValue\": 170,\n *         \"snapValueY\": 640\n *     },\n *     {\n *         \"snapIndex\": 2,\n *         \"snapValue\": 405,\n *         \"snapValueY\": 405\n *     },\n *     {\n *         \"snapIndex\": 3,\n *         \"snapValue\": 760,\n *         \"snapValueY\": 50\n *     },\n *     {\n *         \"snapIndex\": 4, // <-- top snap point\n *         \"snapValue\": 810,\n *         \"snapValueY\": 0\n *     }\n * ]\n * ```\n */\nexport function computeSnapPoints({\n  snapPointsProp,\n  sheetHeight,\n}: {\n  snapPointsProp: number[];\n  sheetHeight: number;\n}): SheetSnapPoint[] {\n  if (snapPointsProp[0] !== 0) {\n    console.error(\n      'First snap point should be 0 to ensure the sheet can be fully closed. ' +\n        `Got: [${snapPointsProp.join(', ')}]`\n    );\n    snapPointsProp.unshift(0);\n  }\n\n  if (snapPointsProp[snapPointsProp.length - 1] !== 1) {\n    console.error(\n      'Last snap point should be 1 to ensure the sheet can be fully opened. ' +\n        `Got: [${snapPointsProp.join(', ')}]`\n    );\n    snapPointsProp.push(1);\n  }\n\n  if (sheetHeight <= 0) {\n    console.error(\n      `Sheet height is ${sheetHeight}, cannot compute snap points. ` +\n        'Make sure the sheet is mounted and has a valid height.'\n    );\n    return [];\n  }\n\n  const snapPointValues = snapPointsProp.map((point) => {\n    // Percentage values e.g. between 0.0 and 1.0\n    if (point > 0 && point <= 1) {\n      return Math.round(point * sheetHeight);\n    }\n\n    return point < 0 ? sheetHeight + point : point; // negative values\n  });\n\n  console.assert(\n    isAscendingOrder(snapPointValues),\n    `Snap points need to be in ascending order got: [${snapPointsProp.join(', ')}]`\n  );\n\n  // Make sure all snap points are within the sheet height\n  snapPointValues.forEach((snap) => {\n    if (snap < 0 || snap > sheetHeight) {\n      console.warn(\n        `Snap point ${snap} is outside of the sheet height ${sheetHeight}. ` +\n          'This can cause unexpected behavior. Consider adjusting your snap points.'\n      );\n    }\n  });\n\n  if (!snapPointValues.includes(sheetHeight)) {\n    console.warn(\n      'Snap points do not include the sheet height.' +\n        'Please include `1` as the last snap point or it will be included automatically.' +\n        'This is to ensure the sheet can be fully opened.'\n    );\n    snapPointValues.push(sheetHeight);\n  }\n\n  return snapPointValues.map((snap, index) => ({\n    snapIndex: index,\n    snapValue: snap, // Absolute value from the bottom of the sheet\n    snapValueY: sheetHeight - snap, // Y value is inverted as `y = 0` means sheet is at the top\n  }));\n}\n\nfunction findClosestSnapPoint({\n  snapPoints,\n  currentY,\n}: {\n  snapPoints: SheetSnapPoint[];\n  currentY: number;\n}) {\n  return snapPoints.reduce((closest, snap) =>\n    Math.abs(snap.snapValueY - currentY) <\n    Math.abs(closest.snapValueY - currentY)\n      ? snap\n      : closest\n  );\n}\n\nfunction findNextSnapPointInDirection({\n  y,\n  snapPoints,\n  dragDirection,\n}: {\n  y: number;\n  snapPoints: SheetSnapPoint[];\n  dragDirection: 'up' | 'down';\n}) {\n  // NOTE: lower Y means higher in the sheet position!\n  if (dragDirection === 'down') {\n    /**\n     * Example:\n     *\n     * [\n     *   { snapIndex: 0, snapValueY: 810 },\n     *   { snapIndex: 1, snapValueY: 640 },\n     *   { snapIndex: 2, snapValueY: 405 }, <-- next down\n     *   ------------- Y = 60 ------------\n     *   { snapIndex: 3, snapValueY: 50 },\n     *   { snapIndex: 4, snapValueY: 0 },\n     * ]\n     */\n    return snapPoints\n      .slice()\n      .reverse()\n      .find((s) => s.snapValueY > y);\n  } else {\n    /**\n     * Example:\n     * [\n     *   { snapIndex: 0, snapValueY: 810 },\n     *   { snapIndex: 1, snapValueY: 640 },\n     *   { snapIndex: 2, snapValueY: 405 },\n     *   ------------- Y = 60 ------------\n     *   { snapIndex: 3, snapValueY: 50 }, <-- next up\n     *   { snapIndex: 4, snapValueY: 0 },\n     * ]\n     */\n    return snapPoints.find((s) => s.snapValueY < y);\n  }\n}\nexport function handleHighVelocityDrag({\n  dragDirection,\n  snapPoints,\n}: {\n  dragDirection: 'up' | 'down';\n  snapPoints: SheetSnapPoint[];\n}) {\n  // Go to either the last or the first snap point depending on the direction\n  const bottomSnapPoint = snapPoints[0];\n  const topSnapPoint = snapPoints[snapPoints.length - 1];\n\n  if (dragDirection === 'down') {\n    return {\n      yTo: bottomSnapPoint.snapValueY,\n      snapIndex: bottomSnapPoint.snapIndex,\n    };\n  }\n  return {\n    yTo: topSnapPoint.snapValueY,\n    snapIndex: topSnapPoint.snapIndex,\n  };\n}\n\nexport function handleLowVelocityDrag({\n  currentSnapPoint,\n  currentY,\n  dragDirection,\n  snapPoints,\n  velocity,\n}: {\n  currentSnapPoint: SheetSnapPoint;\n  currentY: number;\n  dragDirection: 'up' | 'down';\n  snapPoints: SheetSnapPoint[];\n  velocity: number;\n}) {\n  const closestSnapRelativeToCurrentY = findClosestSnapPoint({\n    snapPoints,\n    currentY,\n  });\n\n  /**\n   * If velocity is very low the user has stopped the sheet to a specific\n   * position and we should snap to the closest snap point as there is no\n   * \"momentum\" that would push the sheet further to the given direction\n   */\n  if (Math.abs(velocity) < 20) {\n    return {\n      yTo: closestSnapRelativeToCurrentY.snapValueY,\n      snapIndex: closestSnapRelativeToCurrentY.snapIndex,\n    };\n  }\n\n  /**\n   * If the dragging has a bit more velocity, we instead want to go to\n   * the next snap point in the given direction if it exists\n   */\n  const nextSnapInDirectionRelativeToCurrentY = findNextSnapPointInDirection({\n    y: currentY,\n    snapPoints,\n    dragDirection,\n  });\n\n  if (nextSnapInDirectionRelativeToCurrentY) {\n    return {\n      yTo: nextSnapInDirectionRelativeToCurrentY.snapValueY,\n      snapIndex: nextSnapInDirectionRelativeToCurrentY.snapIndex,\n    };\n  }\n\n  // No snap point down, stay at current\n  return {\n    yTo: currentSnapPoint.snapValueY,\n    snapIndex: currentSnapPoint.snapIndex,\n  };\n}\n", "import {\n  animate,\n  type DragHandler,\n  motion,\n  type Transition,\n  useMotionValue,\n  useReducedMotion,\n  useTransform,\n} from 'motion/react';\nimport React, {\n  forwardRef,\n  useImperativeHandle,\n  useRef,\n  useState,\n} from 'react';\nimport { createPortal } from 'react-dom';\nimport useMeasure from 'react-use-measure';\n\nimport {\n  DEFAULT_DRAG_CLOSE_THRESHOLD,\n  DEFAULT_DRAG_VELOCITY_THRESHOLD,\n  DEFAULT_TWEEN_CONFIG,\n  IS_SSR,\n  REDUCED_MOTION_TWEEN_CONFIG,\n} from './constants';\nimport { SheetContext } from './context';\nimport { useDimensions } from './hooks/use-dimensions';\nimport { useModalEffect } from './hooks/use-modal-effect';\nimport { usePreventScroll } from './hooks/use-prevent-scroll';\nimport { useSheetState } from './hooks/use-sheet-state';\nimport { useStableCallback } from './hooks/use-stable-callback';\nimport { useVirtualKeyboard } from './hooks/use-virtual-keyboard';\nimport {\n  computeSnapPoints,\n  handleHighVelocityDrag,\n  handleLowVelocityDrag,\n} from './snap';\nimport { styles } from './styles';\nimport { type SheetContextType, type SheetProps } from './types';\nimport { applyStyles, waitForElement } from './utils';\n\nexport const Sheet = forwardRef<any, SheetProps>(\n  (\n    {\n      avoidKeyboard = true,\n      children,\n      className = '',\n      detent = 'default',\n      disableDismiss = false,\n      disableDrag: disableDragProp = false,\n      disableScrollLocking = false,\n      dragCloseThreshold = DEFAULT_DRAG_CLOSE_THRESHOLD,\n      dragVelocityThreshold = DEFAULT_DRAG_VELOCITY_THRESHOLD,\n      initialSnap,\n      isOpen,\n      modalEffectRootId,\n      modalEffectThreshold,\n      mountPoint,\n      prefersReducedMotion = false,\n      snapPoints: snapPointsProp,\n      style,\n      tweenConfig = DEFAULT_TWEEN_CONFIG,\n      unstyled = false,\n      onOpenStart,\n      onOpenEnd,\n      onClose,\n      onCloseStart,\n      onCloseEnd,\n      onSnap,\n      onDrag: onDragProp,\n      onDragStart: onDragStartProp,\n      onDragEnd: onDragEndProp,\n      ...rest\n    },\n    ref\n  ) => {\n    const [sheetBoundsRef, sheetBounds] = useMeasure();\n    const sheetRef = useRef<HTMLDivElement>(null);\n    const sheetHeight = Math.round(sheetBounds.height);\n    const [currentSnap, setCurrentSnap] = useState(initialSnap);\n    const snapPoints =\n      snapPointsProp && sheetHeight > 0\n        ? computeSnapPoints({ sheetHeight, snapPointsProp })\n        : [];\n\n    const { windowHeight } = useDimensions();\n    const closedY = sheetHeight > 0 ? sheetHeight : windowHeight;\n    const y = useMotionValue(closedY);\n    const yInverted = useTransform(y, (val) => Math.max(sheetHeight - val, 0));\n    const indicatorRotation = useMotionValue(0);\n\n    const shouldReduceMotion = useReducedMotion();\n    const reduceMotion = Boolean(prefersReducedMotion || shouldReduceMotion);\n    const animationOptions: Transition = {\n      type: 'tween',\n      ...(reduceMotion ? REDUCED_MOTION_TWEEN_CONFIG : tweenConfig),\n    };\n\n    const keyboard = useVirtualKeyboard({\n      isEnabled: isOpen && avoidKeyboard,\n      containerRef: sheetRef,\n    });\n\n    // Disable drag if the keyboard is open to avoid weird behavior\n    const disableDrag = keyboard.isKeyboardOpen || disableDragProp;\n\n    // +2 for tolerance in case the animated value is slightly off\n    const zIndex = useTransform(y, (val) =>\n      val + 2 >= closedY ? -1 : (style?.zIndex ?? 9999)\n    );\n    const visibility = useTransform(y, (val) =>\n      val + 2 >= closedY ? 'hidden' : 'visible'\n    );\n\n    const updateSnap = useStableCallback((snapIndex: number) => {\n      setCurrentSnap(snapIndex);\n      onSnap?.(snapIndex);\n    });\n\n    const getSnapPoint = useStableCallback((snapIndex: number) => {\n      if (snapPointsProp && snapPoints) {\n        if (snapIndex < 0 || snapIndex >= snapPoints.length) {\n          console.warn(\n            `Invalid snap index ${snapIndex}. Snap points are: [${snapPointsProp.join(', ')}] and their computed values are: [${snapPoints\n              .map((point) => point.snapValue)\n              .join(', ')}]`\n          );\n          return null;\n        }\n        return snapPoints[snapIndex];\n      }\n      return null;\n    });\n\n    const snapTo = useStableCallback(async (snapIndex: number) => {\n      if (!snapPointsProp) {\n        console.warn('Snapping is not possible without `snapPoints` prop.');\n        return;\n      }\n\n      const snapPoint = getSnapPoint(snapIndex);\n\n      if (snapPoint === null) {\n        console.warn(`Invalid snap index ${snapIndex}.`);\n        return;\n      }\n\n      if (snapIndex === 0) {\n        onClose();\n        return;\n      }\n\n      await animate(y, snapPoint.snapValueY, {\n        ...animationOptions,\n        onComplete: () => updateSnap(snapIndex),\n      });\n    });\n\n    const blurActiveInput = useStableCallback(() => {\n      // Find focused input inside the sheet and blur it when dragging starts\n      // to prevent a weird ghost caret \"bug\" on mobile\n      const focusedElement = document.activeElement as HTMLElement | null;\n      if (!focusedElement || !sheetRef.current) return;\n\n      const isInput =\n        focusedElement.tagName === 'INPUT' ||\n        focusedElement.tagName === 'TEXTAREA';\n\n      // Only blur the focused element if it's inside the sheet\n      if (isInput && sheetRef.current.contains(focusedElement)) {\n        focusedElement.blur();\n      }\n    });\n\n    const onDrag = useStableCallback<DragHandler>((event, info) => {\n      onDragProp?.(event, info);\n\n      const currentY = y.get();\n\n      // Update drag indicator rotation based on drag velocity\n      const velocity = y.getVelocity();\n      if (velocity > 0) indicatorRotation.set(10);\n      if (velocity < 0) indicatorRotation.set(-10);\n\n      // Make sure user cannot drag beyond the top of the sheet\n      y.set(Math.max(currentY + info.delta.y, 0));\n    });\n\n    const onDragStart = useStableCallback<DragHandler>((event, info) => {\n      blurActiveInput();\n      onDragStartProp?.(event, info);\n    });\n\n    const onDragEnd = useStableCallback<DragHandler>((event, info) => {\n      blurActiveInput();\n      onDragEndProp?.(event, info);\n\n      const currentY = y.get();\n\n      let yTo = 0;\n\n      const currentSnapPoint =\n        currentSnap !== undefined ? getSnapPoint(currentSnap) : null;\n\n      if (currentSnapPoint) {\n        const dragOffsetDirection = info.offset.y > 0 ? 'down' : 'up';\n        const dragVelocityDirection = info.velocity.y > 0 ? 'down' : 'up';\n        const isHighVelocity =\n          Math.abs(info.velocity.y) > dragVelocityThreshold;\n\n        let result: { yTo: number; snapIndex: number | undefined };\n\n        if (isHighVelocity) {\n          result = handleHighVelocityDrag({\n            snapPoints,\n            dragDirection: dragVelocityDirection,\n          });\n        } else {\n          result = handleLowVelocityDrag({\n            currentSnapPoint,\n            currentY,\n            dragDirection: dragOffsetDirection,\n            snapPoints,\n            velocity: info.velocity.y,\n          });\n        }\n\n        yTo = result.yTo;\n\n        // If disableDismiss is true, prevent closing via gesture\n        if (disableDismiss && yTo + 1 >= sheetHeight) {\n          // Use the bottom-most open snap point\n          const bottomSnapPoint = snapPoints.find((s) => s.snapValue > 0);\n\n          if (bottomSnapPoint) {\n            yTo = bottomSnapPoint.snapValueY;\n            updateSnap(bottomSnapPoint.snapIndex);\n          } else {\n            // If no open snap points available, stay at current position\n            yTo = currentY;\n          }\n        } else if (result.snapIndex !== undefined) {\n          updateSnap(result.snapIndex);\n        }\n      } else if (\n        info.velocity.y > dragVelocityThreshold ||\n        currentY > sheetHeight * dragCloseThreshold\n      ) {\n        // Close the sheet if dragged past the threshold or if the velocity is high enough\n        // But only if disableDismiss is false\n        if (disableDismiss) {\n          // If disableDismiss, snap back to the open position\n          yTo = 0;\n        } else {\n          yTo = closedY;\n        }\n      }\n\n      // Update the spring value so that the sheet is animated to the snap point\n      animate(y, yTo, animationOptions);\n\n      // +1px for imprecision tolerance\n      // Only call onClose if disableDismiss is false or if we're actually closing\n      if (yTo + 1 >= sheetHeight && !disableDismiss) {\n        onClose();\n      }\n\n      // Reset indicator rotation after dragging\n      indicatorRotation.set(0);\n    });\n\n    useImperativeHandle(ref, () => ({\n      y,\n      yInverted,\n      height: sheetHeight,\n      snapTo,\n    }));\n\n    useModalEffect({\n      y,\n      detent,\n      sheetHeight,\n      snapPoints,\n      rootId: modalEffectRootId,\n      startThreshold: modalEffectThreshold,\n    });\n\n    /**\n     * Motion should handle body scroll locking but it's not working properly on iOS.\n     * Scroll locking from React Aria seems to work much better ðŸ¤·â€â™‚ï¸\n     */\n    usePreventScroll({\n      isDisabled: disableScrollLocking || !isOpen,\n    });\n\n    const state = useSheetState({\n      isOpen,\n      onOpen: async () => {\n        onOpenStart?.();\n\n        /**\n         * This is not very React-y but we need to wait for the sheet\n         * but we need to wait for the sheet to be rendered and visible\n         * before we can measure it and animate it to the initial snap point.\n         */\n        await waitForElement('react-modal-sheet-container');\n\n        const initialSnapPoint =\n          initialSnap !== undefined ? getSnapPoint(initialSnap) : null;\n\n        const yTo = initialSnapPoint?.snapValueY ?? 0;\n\n        await animate(y, yTo, animationOptions);\n\n        if (initialSnap !== undefined) {\n          updateSnap(initialSnap);\n        }\n\n        onOpenEnd?.();\n      },\n      onClosing: async () => {\n        onCloseStart?.();\n\n        await animate(y, closedY, animationOptions);\n\n        onCloseEnd?.();\n      },\n    });\n\n    const dragProps: SheetContextType['dragProps'] = {\n      drag: 'y',\n      dragElastic: 0,\n      dragMomentum: false,\n      dragPropagation: false,\n      onDrag,\n      onDragStart,\n      onDragEnd,\n    };\n\n    const context: SheetContextType = {\n      currentSnap,\n      detent,\n      disableDrag,\n      dragProps,\n      indicatorRotation,\n      avoidKeyboard,\n      sheetBoundsRef,\n      sheetRef,\n      unstyled,\n      y,\n    };\n\n    const sheet = (\n      <SheetContext.Provider value={context}>\n        <motion.div\n          {...rest}\n          ref={ref}\n          data-sheet-state={state}\n          className={`react-modal-sheet-root ${className}`}\n          style={{\n            ...applyStyles(styles.root, unstyled),\n            zIndex,\n            visibility,\n            ...style,\n          }}\n        >\n          {state !== 'closed' ? children : null}\n        </motion.div>\n      </SheetContext.Provider>\n    );\n\n    if (IS_SSR) return sheet;\n\n    return createPortal(sheet, mountPoint ?? document.body);\n  }\n);\n\nSheet.displayName = 'Sheet';\n", "import type { MotionValue } from 'motion/react';\n\nimport { SheetBackdrop } from './SheetBackdrop';\nimport { SheetContainer } from './SheetContainer';\nimport { SheetContent } from './SheetContent';\nimport { SheetDragIndicator } from './SheetDragIndicator';\nimport { SheetHeader } from './SheetHeader';\nimport { Sheet as SheetBase } from './sheet';\nimport type { SheetCompound } from './types';\n\nexport interface SheetRef {\n  y: MotionValue<number>;\n  yInverted: MotionValue<number>;\n  height: number;\n  snapTo: (index: number) => Promise<void>;\n}\n\nexport const Sheet: SheetCompound = Object.assign(SheetBase, {\n  Container: SheetContainer,\n  Header: SheetHeader,\n  DragIndicator: SheetDragIndicator,\n  Content: SheetContent,\n  Backdrop: SheetBackdrop,\n});\n\nexport { useScrollPosition } from './hooks/use-scroll-position';\nexport { useVirtualKeyboard } from './hooks/use-virtual-keyboard';\n\n// Export types\nexport type {\n  SheetBackdropProps,\n  SheetContainerProps,\n  SheetContentProps,\n  SheetDetent,\n  SheetDragIndicatorProps,\n  SheetHeaderProps,\n  SheetProps,\n  SheetSnapPoint,\n  SheetStateInfo,\n  SheetTweenConfig,\n} from './types';\n"],
  "mappings": "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",
  "names": ["createDebounce", "callback", "ms", "timeoutId", "args", "useMeasure", "debounce", "scroll", "polyfill", "offsetSize", "ResizeObserver", "bounds", "set", "useState", "state", "useRef", "scrollDebounce", "resizeDebounce", "mounted", "useEffect", "forceRefresh", "resizeChange", "scrollChange", "useMemo", "left", "top", "width", "height", "bottom", "right", "x", "y", "size", "areBoundsEqual", "removeListeners", "element", "addListeners", "scrollContainer", "ref", "node", "findScrollContainers", "useOnWindowScroll", "useOnWindowResize", "onWindowResize", "cb", "onScroll", "enabled", "result", "overflow", "overflowX", "overflowY", "prop", "keys", "a", "b", "key", "styles", "React", "forwardRef", "motion", "element", "isScrollable", "scroll", "useEffect", "useState", "useRef", "useCallback", "useTransform", "Sheet"]
}
